// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Verifique se as variáveis de ambiente estão sendo usadas corretamente
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://xspmibkhtmnetivtnjox.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "sbp_v0_d631951ba033dd61c73092421d14982d3ff3fd5b";

const isBrowser = typeof window !== 'undefined';

// Verificar se as configurações estão definidas
if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
  console.error('Variáveis de ambiente para Supabase não estão configuradas corretamente');
}

console.log('Conectando ao Supabase URL:', SUPABASE_URL);

// Função para verificar se o servidor Supabase está disponível
const checkSupabaseAvailability = async () => {
  try {
    const response = await fetch(`${SUPABASE_URL}/rest/v1/`, {
      headers: {
        "apikey": SUPABASE_PUBLISHABLE_KEY,
        "Authorization": `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    });
    return response.ok;
  } catch (error) {
    console.error('Erro ao verificar disponibilidade do Supabase:', error);
    return false;
  }
};

// Verificar disponibilidade do Supabase
checkSupabaseAvailability().then(isAvailable => {
  if (!isAvailable) {
    console.error('ALERTA: O servidor Supabase parece estar indisponível. Isso pode causar erros na aplicação.');
    // Se estiver em um navegador, mostrar mensagem para o usuário
    if (isBrowser) {
      const errorDiv = document.createElement('div');
      errorDiv.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; background-color: #ff5252; color: white; padding: 10px; text-align: center; z-index: 9999; font-weight: bold;';
      errorDiv.innerText = 'O servidor de dados está temporariamente indisponível. Algumas funcionalidades podem não funcionar corretamente.';
      document.body.appendChild(errorDiv);
    }
  }
});

export const supabase = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      storage: isBrowser ? localStorage : undefined,
      flowType: 'pkce',
      detectSessionInUrl: false,
      debug: process.env.NODE_ENV === 'development'
    },
    realtime: {
      params: {
        eventsPerSecond: 10,
      },
    },
    global: {
      headers: {
        'Content-Type': 'application/json',
      },
    },
  }
);

// Mock do cliente Supabase para uso quando o servidor estiver indisponível
const createMockClient = () => {
  const mockResponse = { data: null, error: { message: "Servidor Supabase indisponível", code: "SERVER_OFFLINE" } };

  return {
    from: () => ({
      select: () => Promise.resolve(mockResponse),
      insert: () => Promise.resolve(mockResponse),
      update: () => Promise.resolve(mockResponse),
      delete: () => Promise.resolve(mockResponse),
      eq: () => ({ select: () => Promise.resolve(mockResponse) }),
      order: () => ({ select: () => Promise.resolve(mockResponse) }),
    }),
    auth: {
      signIn: () => Promise.resolve(mockResponse),
      signUp: () => Promise.resolve(mockResponse),
      signOut: () => Promise.resolve(mockResponse),
      getSession: () => Promise.resolve({ data: { session: null }, error: null }),
    },
    storage: {
      from: () => ({
        upload: () => Promise.resolve(mockResponse),
        getPublicUrl: () => ({ data: { publicUrl: '' } }),
      }),
    }
  };
};

// Wrapper para o cliente Supabase que tenta usar o cliente real, mas volta para o mock em caso de erro
const createSupabaseClientWithFallback = (realClient: any) => {
  return new Proxy(realClient, {
    get: (target, prop) => {
      const original = target[prop];
      if (typeof original === 'function') {
        return async (...args: any[]) => {
          try {
            const result = await original.apply(target, args);
            return result;
          } catch (error) {
            console.error(`Erro ao acessar Supabase (${String(prop)}):`, error);
            // Usar implementação mock
            const mock = createMockClient();
            if (mock[prop]) {
              return mock[prop](...args);
            }
            return { data: null, error: { message: "Operação indisponível", code: "OPERATION_UNAVAILABLE" } };
          }
        };
      }
      return original;
    }
  });
};

// Substituir o cliente Supabase pelo wrapper com fallback
const supabaseWithFallback = createSupabaseClientWithFallback(supabase);

// Add helper function to check authentication state
export const isAuthenticated = async (): Promise<boolean> => {
  try {
    const { data } = await supabase.auth.getSession();
    return !!data.session;
  } catch (error) {
    console.error('Erro ao verificar autenticação:', error);
    return false;
  }
};

// Add helper to get current user ID
export const getCurrentUserId = async (): Promise<string | null> => {
  try {
    const { data } = await supabase.auth.getSession();
    return data.session?.user?.id || null;
  } catch (error) {
    console.error('Erro ao obter ID do usuário atual:', error);
    return null;
  }
};
